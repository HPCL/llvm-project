# Instead of using artifacts, just build in an NFS-mounted directory,
# $BUILD_DIR, that's unique to each pipeline in case there are concurrent
# pipelines.  Why not use artifacts?
#
# - LLVM's build directory is huge.  For me, it's 46G when including just
#   the clang and openmp subprojects, which are required for Clacc, and it's
#   85G when including nearly all subprojects.
# - At this size, it takes a long time to upload/download between stages and
#   can be rejected as an upload because of its size.  For me, it added 20
#   min to the already 30 min build of that 46G and then was rejected.
# - Artifacts are posted for download and stored long past when it's useful
#   for humans to download the LLVM build directory, which is typically
#   never.
# - We could squash the pipeline to one stage to avoid the need for
#   artifacts, but pipeline stages are a convenient way to view results when
#   debugging.
#
# The NFS solution used here is based on the following comment (which is in
# response to a proposal for a gitlab feature that would solve this
# problem):
#
#   https://gitlab.com/gitlab-org/gitlab/issues/29265#note_225288132
#
# However, because the NFS-mounted build directory name is different for each
# pipeline, ccache misses if we compile within it.  Thus, we set
# CCACHE_NOHASHDIR and CCACHE_BASEDIR (neither alone proves sufficient), as
# suggested by the ccache manual.  CCACHE_NOHASHDIR can lead to incorrect
# directory names in debugging symbols, but currently we don't expect those to
# matter to our CI builds.
variables:
  BUILD_DIR_PROJ: $CI_BUILDS_DIR/$CI_PROJECT_PATH_SLUG-builds
  BUILD_DIR: $CI_BUILDS_DIR/$CI_PROJECT_PATH_SLUG-builds/$CI_PIPELINE_ID-$BUILD_ID
  BUILD_DIRS: $CI_BUILDS_DIR/$CI_PROJECT_PATH_SLUG-builds/$CI_PIPELINE_ID-*
  LLVM_CCACHE_PARAMS: 'CCACHE_CPP2=yes CCACHE_NOHASHDIR=yes CCACHE_BASEDIR=$CI_BUILDS_DIR/$CI_PROJECT_PATH_SLUG-builds'

stages:
  - setup
  - config
  - build
  - openmp
  - test
  - cleanup
  - manual cleanup

#-------------------------------------------------
# build configurations
#
# Test every architecture with a debug build (thus checking assertions) using
# python3.  There are many kolds, so use them to check configuration choices
# that are hopefully orthogonal to the architecture.
#-------------------------------------------------

.leconte:
  tags: [shell, leconte]
  variables:
    BUILD_ID: leconte
    MODULES: cmake/3.19.2 gnu/9.2.0 nvhpc/20.11
    CMAKE: cmake
    NINJA: ninja
    PYTHON: /usr/bin/python3
    CMAKE_BUILD_TYPE: Debug
    CMAKE_OFFLOAD_CONFIG_CLANG:
      -DCLANG_OPENMP_NVPTX_DEFAULT_ARCH=sm_70
      -DCLANG_ACC_TEST_EXE_X86_64=False
      -DCLANG_ACC_TEST_EXE_PPC64LE=True
      -DCLANG_ACC_TEST_EXE_NVPTX64=True
    CMAKE_OFFLOAD_CONFIG_OPENMP:
      -DCUDA_TOOLKIT_ROOT_DIR=$NVHPC/Linux_ppc64le/20.11/cuda/11.0
      -DLIBOMPTARGET_NVPTX_COMPUTE_CAPABILITIES=70

.kold:
  tags: [shell, kold]
  variables:
    BUILD_ID: kold
    MODULES: gnu/9.1.0
    CMAKE: cmake3
    NINJA: ninja-build
    PYTHON: /usr/bin/python3
    CMAKE_BUILD_TYPE: Debug
    CMAKE_OFFLOAD_CONFIG_CLANG:
      -DCLANG_ACC_TEST_EXE_X86_64=True
      -DCLANG_ACC_TEST_EXE_PPC64LE=False
      -DCLANG_ACC_TEST_EXE_NVPTX64=False
    CMAKE_OFFLOAD_CONFIG_OPENMP:
      ""

# Sometimes bugs cause only release builds to fail.  For example, debugging
# macros might accidentally be used but not defined in release builds.
.release:
  extends: [.kold]
  variables:
    BUILD_ID: release
    CMAKE_BUILD_TYPE: Release

# Not setup or cleanup.
.non-utility:
  dependencies: []
  variables:
    GIT_STRATEGY: none
  before_script:
    - echo $MODULES
    - module load $MODULES
    - pwd
    - echo $BUILD_DIR
    - cd $BUILD_DIR/build
  after_script:
    - echo "$LLVM_CCACHE_PARAMS"
    - env $LLVM_CCACHE_PARAMS ccache -sp
    - du -hs $BUILD_DIR/build

#-------------------------------------------------
# setup
#-------------------------------------------------

.setup:
  stage: setup
  script:
    - pwd
    - echo $BUILD_DIR_PROJ
    # Try to remove anything older than 6 hours that was left by a previous
    # pipeline for this project.  Doing this in the setup stage instead of
    # cleanup stage ensures that it runs before a new job even if prior jobs
    # failed or were canceled.  git clone creates files with old modification
    # times, so check file creation time (-cmin) instead.
    - find $BUILD_DIR_PROJ -cmin +360 -delete || true
    - mkdir -p $BUILD_DIR_PROJ
    - echo $BUILD_DIR
    # Remove this build config's build directory if it already exists.  It
    # might exist if, for example, this setup job previously failed due to a
    # transient Gitlab/ExCL problem.
    - rm -rf $BUILD_DIR
    - mkdir $BUILD_DIR
    - mkdir $BUILD_DIR/build
    # Clone the runner's git clone into the NFS-mounted build directory.  We
    # cannot use the runner's git clone directly because its location relative
    # to the build directory varies across runners, and that would cause ccache
    # to miss whenever the runner changes no matter how we set CCACHE_BASEDIR.
    # We've also tried creating a symlink to the runner's git clone at the
    # start of every job, but that causes ccache to miss in the same manner, so
    # apparently the symlink is expanded somewhere.
    - git --version
    - time git clone `pwd` $BUILD_DIR/source

leconte (setup):
  extends: [.leconte, .setup]

kold (setup):
  extends: [.kold, .setup]

release (setup):
  extends: [.release, .setup]

#-------------------------------------------------
# cleanup
#-------------------------------------------------

.rm-build-dir:
  variables:
    GIT_STRATEGY: none
  script:
    - pwd
    - echo $BUILD_DIR
    - rm -rf $BUILD_DIR
    - rmdir $BUILD_DIR_PROJ || true

.cleanup:
  stage: cleanup
  extends: .rm-build-dir

.manual-cleanup:
  stage: manual cleanup
  extends: .rm-build-dir
  when: manual
  needs: []

leconte (cleanup):
  extends: [.leconte, .cleanup]
  needs:
    - job: leconte (test)
      artifacts: false

kold (cleanup):
  extends: [.kold, .cleanup]
  needs:
    - job: kold (test)
      artifacts: false

release (cleanup):
  extends: [.release, .cleanup]
  needs:
    - job: release (test)
      artifacts: false

leconte (manual cleanup):
  extends: [.leconte, .manual-cleanup]

kold (manual cleanup):
  extends: [.kold, .manual-cleanup]

release (manual cleanup):
  extends: [.release, .manual-cleanup]

z-cleanup-pipeline-builds:
  stage: manual cleanup
  when: manual
  needs: []
  tags: [shell, kold]
  variables:
    GIT_STRATEGY: none
  script:
    - echo $BUILD_DIRS
    - rm -rf $BUILD_DIRS

z-cleanup-project-builds:
  stage: manual cleanup
  when: manual
  needs: []
  tags: [shell, kold]
  variables:
    GIT_STRATEGY: none
  script:
    - echo $BUILD_DIR_PROJ
    - rm -rf $BUILD_DIR_PROJ

#-------------------------------------------------
# config
#-------------------------------------------------

.config:
  extends: .non-utility
  stage: config
  script:
    - echo $CMAKE
    - $CMAKE --version
    - echo $CMAKE_BUILD_TYPE
    - echo $GCC_DIR
    - echo $PYTHON
    - $PYTHON --version
    - echo $LLVM_CCACHE_PARAMS
    - echo $CMAKE_OFFLOAD_CONFIG_CLANG
    - echo $CMAKE_OFFLOAD_CONFIG_OPENMP
    - time $CMAKE -G Ninja
                  -DCMAKE_BUILD_TYPE=$CMAKE_BUILD_TYPE
                  -DLLVM_CCACHE_BUILD=ON
                  -DLLVM_USE_SPLIT_DWARF=true
                  -DLLVM_USE_LINKER=gold
                  -DCMAKE_C_COMPILER=gcc
                  -DCMAKE_CXX_COMPILER=g++
                  -DGCC_INSTALL_PREFIX=$GCC_DIR
                  -DLLVM_ENABLE_PROJECTS='clang;openmp'
                  -DPython3_EXECUTABLE=$PYTHON
                  -DLLVM_CCACHE_PARAMS="$LLVM_CCACHE_PARAMS"
                  -DLLVM_LIT_ARGS='-s -vv'
                  $CMAKE_OFFLOAD_CONFIG_CLANG
                  $CMAKE_OFFLOAD_CONFIG_OPENMP
                  ../source/llvm
      |& tee $CI_PROJECT_DIR/cmake-log.txt
    - cp CMakeCache.txt $CI_PROJECT_DIR
  artifacts:
    when: always
    paths: [cmake-log.txt, CMakeCache.txt]

leconte (config):
  extends: [.leconte, .config]
  needs:
    - job: leconte (setup)
      artifacts: false

kold (config):
  extends: [.kold, .config]
  needs:
    - job: kold (setup)
      artifacts: false

release (config):
  extends: [.release, .config]
  needs:
    - job: release (setup)
      artifacts: false

#-------------------------------------------------
# build
#-------------------------------------------------

.build:
  extends: .non-utility
  stage: build
  script:
    - echo $NINJA
    - $NINJA --version
    - time $NINJA -l `nproc` |& tee $CI_PROJECT_DIR/build-log.txt
  artifacts:
    when: always
    paths: [build-log.txt]

leconte (build):
  extends: [.leconte, .build]
  needs:
    - job: leconte (config)
      artifacts: false

kold (build):
  extends: [.kold, .build]
  needs:
    - job: kold (config)
      artifacts: false

release (build):
  extends: [.release, .build]
  needs:
    - job: release (config)
      artifacts: false

#-------------------------------------------------
# openmp
#
# Rebuild the openmp subproject with the clang we just built in order to
# produce libomptarget-*.bc libraries.  Without these, supposedly the worst
# that can happen is degraded performance.  However, we've also seen failures,
# in particular when offloading to nvptx64, that we could no longer reproduce
# after building these.
#-------------------------------------------------

.openmp:
  extends: .non-utility
  stage: openmp
  script:
    - echo $CMAKE
    - $CMAKE --version
    - echo $CMAKE_BUILD_TYPE
    - echo $GCC_DIR
    - echo $CMAKE_OFFLOAD_CONFIG_OPENMP
    - mkdir ../build-openmp
    - cd ../build-openmp
    - time $CMAKE -G Ninja
                  -DCMAKE_BUILD_TYPE=$CMAKE_BUILD_TYPE
                  -DCMAKE_INSTALL_PREFIX=../install-openmp
                  -DOPENMP_LLVM_TOOLS_DIR=$(pwd)/../build/bin
                  -DCMAKE_C_COMPILER=$(pwd)/../build/bin/clang
                  -DCMAKE_CXX_COMPILER=$(pwd)/../build/bin/clang++
                  -DCMAKE_C_FLAGS=--gcc-toolchain=$GCC_DIR
                  -DCMAKE_CXX_FLAGS=--gcc-toolchain=$GCC_DIR
                  $CMAKE_OFFLOAD_CONFIG_OPENMP
                  ../source/openmp
      |& tee $CI_PROJECT_DIR/cmake-log.txt
    - cp CMakeCache.txt $CI_PROJECT_DIR/CMakeCache.txt
    - echo $NINJA
    - $NINJA --version
    - time $NINJA -l `nproc` |& tee $CI_PROJECT_DIR/build-log.txt
    - time $NINJA install |& tee $CI_PROJECT_DIR/install-log.txt
    - cp ../install-openmp/lib/* ../build/lib
  artifacts:
    when: always
    paths:
      - cmake-log.txt
      - CMakeCache.txt
      - build-log.txt
      - install-log.txt

leconte (openmp):
  extends: [.leconte, .openmp]
  needs:
    - job: leconte (build)
      artifacts: false

kold (openmp):
  extends: [.kold, .openmp]
  needs:
    - job: kold (build)
      artifacts: false

release (openmp):
  extends: [.release, .openmp]
  needs:
    - job: release (build)
      artifacts: false

#-------------------------------------------------
# tests
#
# The additional build required for the test suite can be very noisy and
# exceed the log output limit.  Run that first, grep for key text, and
# make the full version an artifact.
#
# When there are fails, the test suite run can be very noisy too and
# exceed the log output limit.  It's hard to grep for just the important
# stuff, so just print it all but also dump to an artifact.
#-------------------------------------------------

.test:
  extends: .non-utility
  stage: test
  script:
    - echo $CHECK_TARGETS
    - echo $NINJA
    - $NINJA --version
    - time LIT_OPTS='--filter=xxxxxxxxx --allow-empty-runs'
           $NINJA -l `nproc` check-all
      |& tee $CI_PROJECT_DIR/check-all-build-log.txt
      | grep '^\[[0-9]\+/[0-9]\+]\|\<error:'
    - time FILECHECK_OPTS='-dump-input-filter=all -vv -color'
           LIT_OPTS="--xunit-xml-output $CI_PROJECT_DIR/check-all.xml"
           $NINJA -l `nproc` check-all
      |& tee $CI_PROJECT_DIR/check-all-log.txt;
  artifacts:
    when: always
    paths: [check-all-build-log.txt, check-all-log.txt, check-all.xml]
    reports:
      junit: check-all.xml

leconte (test):
  extends: [.leconte, .test]
  needs:
    - job: leconte (openmp)
      artifacts: false

kold (test):
  extends: [.kold, .test]
  needs:
    - job: kold (openmp)
      artifacts: false

release (test):
  extends: [.release, .test]
  needs:
    - job: release (openmp)
      artifacts: false
